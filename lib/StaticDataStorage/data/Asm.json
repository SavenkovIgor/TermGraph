{
    "name": "Asm",
    "terms": [
        {
            "termDef": "AH - 1 {байтный} {регистр}"
        },
        {
            "termDef": "AL - 1 {байтный} {регистр}"
        },
        {
            "termDef": "Байт - 8 {бит}"
        },
        {
            "termDef": "Регистр - устройство для записи, хранения и считывания N-ого количества {бит}. Обычно размерность кратна {байту}"
        },
        {
            "termDef": "AX - 16 {битный} {регистр}. Состоит из {AH} и {AL}. Регистр аккумулятор"
        },
        {
            "termDef": "BH - 1 {байтный} {регистр}"
        },
        {
            "termDef": "BL - 1 {байтный} {регистр}"
        },
        {
            "termDef": "BX - 16 {байтный} {регистр}. Состоит из {BH} и {BL}. Регистр базы"
        },
        {
            "termDef": "CH - часть {регистра} счётчика. Размер 1 {байт}"
        },
        {
            "termDef": "CL - часть {регистра} счётчика. Размер 1 {байт}"
        },
        {
            "termDef": "CX - {регистр} счётчика длинной 2 {байта}. Состоит из {регистров} {CH} и {CL}"
        },
        {
            "termDef": "DL - часть {регистра} данных. Размер 1 {байт}"
        },
        {
            "termDef": "DX - 16 битный регистр данных. Состоит из {DH} и {DL}"
        },
        {
            "termDef": "DH - часть {регистра} данных. Размер 1 {байт}"
        },
        {
            "termDef": "EAX - 32 {битный} {регистр}. Содержит в себе {AX}"
        },
        {
            "termDef": "EBX - 32х битный регистр. Частично перекрывает {BX}"
        },
        {
            "termDef": "0 префикс для 16h - чтобы ассемблер мог отличить 16ое число, начинающееся с буквы, от обычной метки или имени переменной, перед таким числом нужно ставить 0"
        },
        {
            "termDef": "SI - {регистр}, обычно содержащий индекс источника данных"
        },
        {
            "termDef": "DI - {регистр}, обычно содержащий Индекс приемника"
        },
        {
            "termDef": "bp - {регистр} для работы со {стеком}"
        },
        {
            "termDef": "SP - {регистр} содержащий адрес вершины {стека}"
        },
        {
            "termDef": "Стек - {абстрактный тип данных}. Который представляет из себя {очередь}, организованную по принципу {LIFO}. В аппаратной архитектуре, целый {сегмент} может быть выделен под стек"
        },
        {
            "termDef": "CS - code segment. {Сегментный регистр} кода"
        },
        {
            "termDef": "DS - data segment. {сегментный регистр} данных"
        },
        {
            "termDef": "ES - дополнительный {сегментный регистр}"
        },
        {
            "termDef": "SS - stack segment. {Сегментный регистр} {стека}"
        },
        {
            "termDef": "add - {арифметическая инструкция}"
        },
        {
            "termDef": "sub - "
        },
        {
            "termDef": "inc - {арифметическая инструкция}. Увеличивает число на 1"
        },
        {
            "termDef": "dec - "
        },
        {
            "termDef": "Команда-приемник-источник - "
        },
        {
            "termDef": "Сегмент - небольшой, отдельно адресуемый участок памяти, идущий подряд, фиксированного размера"
        },
        {
            "termDef": "org 100h - команда ассемблеру для установки смещения внутри сегмента памяти"
        },
        {
            "termDef": "Арифметическая инструкции - {Инструкция}"
        },
        {
            "termDef": "IP - instruction pointer {регистр}, содержащий {адрес} {инструкции}, которая будет выполнена следующей"
        },
        {
            "termDef": "В реальном режиме для адресации используется сегмент и смещение - "
        },
        {
            "termDef": "call - {Инструкция перехода} которая используется для вызова функции. Кладет в {стек} адрес возврата"
        },
        {
            "termDef": "ret - достает из {стека} только {смещение} для возврата; процедура должна находиться в том же {сегменте}, из которого ее вызывают"
        },
        {
            "termDef": "push - {Инструкция работы со стеком}, которая копирует переменную в {стек} и увеличивает {sp}"
        },
        {
            "termDef": "pop - {Инструкция работы со стеком}. Копирует значение из {стека} и кладет в переданную переменную, автоматически увеличивая {sp}"
        },
        {
            "termDef": "cli - операция запрета {прерывания}"
        },
        {
            "termDef": "sti - операция разрешения {прерываний}"
        },
        {
            "termDef": "Прерывание - своего рода процедура, не имеющая имени но имеющая личный номер"
        },
        {
            "termDef": "nop - нет операнда. {Инструкция}, которая ничего не делает"
        },
        {
            "termDef": "cmp - сравнение"
        },
        {
            "termDef": "В одинарных кавычках можно вставлять символ и он сам скастуется в ASCII - "
        },
        {
            "termDef": "jz - {инструкция условного перехода} если {флаг нуля} установлен"
        },
        {
            "termDef": "Регистр флагов - {регистр} процессора содержащий {флаги} описывающие его текущее состояние"
        },
        {
            "termDef": "Флаг нуля - {флаг} в {регистре флагов}. Устанавливается в 1 если предыдущая {команда сравнения} была верной"
        },
        {
            "termDef": "je - команда идентичная {jz}. При ассемблировании будет заменена jz"
        },
        {
            "termDef": "Инструкция условного перехода - {Инструкция перехода}, в которой переход происходит только при выполнении определенного условия"
        },
        {
            "termDef": "Инструкция перехода - инструкция, изменяющая то, какая {инструкция} будет выполнена следующей, путем модификации регистра {ip}"
        },
        {
            "termDef": "Инструкция безусловного перехода - "
        },
        {
            "termDef": "jmp - "
        },
        {
            "termDef": "Расширенный ASCII код - "
        },
        {
            "termDef": "Флаг переноса - 1 битный {флаг} в {регистре флагов} который, равен 1 если в результате арифметической операции произошло переполнение. carry flag. Cf"
        },
        {
            "termDef": "jc - команда {условного перехода} если {флаг переноса} установлен"
        },
        {
            "termDef": "jnc - {Инструкция условного перехода} если {флаг переноса} не установлен"
        },
        {
            "termDef": "dw - "
        },
        {
            "termDef": "Есть нуль символ - "
        },
        {
            "termDef": "Флаг - один или несколько {бит} памяти, характеризующие состояние какого либо объекта"
        },
        {
            "termDef": "Бит - один разряд двоичного кода. Может быть только в 2х взаимоисключающих состояниях: 0 или 1. Минимальная единица информации"
        },
        {
            "termDef": "Резидентная программа - программа которая постоянно находится в памяти. Часто является обработчиком прерывания"
        },
        {
            "termDef": "Перехват прерываний - "
        },
        {
            "termDef": "Программные прерывания - {прерывания}, которые вызывает непосредственно программа при помощи команды int (отсюда и название — программные), например, для того чтобы получить код клавиши, которую нажмет пользователь (mov ah,0/int 16h), или вывести некоторую строку на экран (mov ah,9/int 21h)"
        },
        {
            "termDef": "Аппаратные прывания - {прерывания}, которые вызываются самостоятельно процессором (аппаратурой компьютера) при возникновении каких-либо событий. При этом процессор прекращает выполнение текущей программы, сохраняет в стеке регистры ss, sp и флаги, вызывает соответствующее прерывание, а затем восстанавливает сохраненные регистры и продолжает выполнение текущей программы"
        },
        {
            "termDef": "pushf - аналог инструкции {push} для {регистра флагов}"
        },
        {
            "termDef": "dword - "
        },
        {
            "termDef": "ptr - "
        },
        {
            "termDef": "iret - достает из {стека} {сегмент}, {смещение} и {регистр флагов}. Используется для выхода из {прерываний}"
        },
        {
            "termDef": "popf - аналог {инструкции} {pop} для {регистра флагов}"
        },
        {
            "termDef": "xchg - {Инструкция} обмена {регистров}"
        },
        {
            "termDef": "lods - группа {инструкций}. загружает в {регистр} {ax}/{al} значение по адресу [{ds}:{si}] и автоматически увеличивает {si} на 1 или 2"
        },
        {
            "termDef": "lodsb - вариант инструкции {lods} для 1 {байта}"
        },
        {
            "termDef": "lodsw - вариант {инструкции} {lods} для 2 {байт}"
        },
        {
            "termDef": "Сегментный регистр - {Регистр} указывающий на начало {сегмента}"
        },
        {
            "termDef": "stos - заносит число из {al} в {es}:{di}"
        },
        {
            "termDef": "rep - {Инструкция} префикс. Повторит следующую за ней инструкцию столько раз, сколько указано в {cx}"
        },
        {
            "termDef": "xor - {Логическая инструкция} {исключающее или}"
        },
        {
            "termDef": "movs - инструкция для работы с массивами данных, которая копирует данные из {ds}:{si} в {es}:{di} в количестве, указанном в регистре {cx}"
        },
        {
            "termDef": "Модель памяти - соглашение по структуре и способу расположения кода и данных в {сегментах} памяти"
        },
        {
            "termDef": "Tiny - {Модель памяти} где код, данные и {стек} располагаются в одном {сегменте}"
        },
        {
            "termDef": "Small - {Модель памяти} где код размещается в одном сегменте, а данные и {стек} в другом"
        },
        {
            "termDef": "Счётчик - "
        },
        {
            "termDef": "Compact - {Модель памяти} где код располагается в одном сегменте, а данные в другом (возможно нескольких)"
        },
        {
            "termDef": "Medium - {Модель памяти} в которой код в нескольких сегментах, а данные в одном"
        },
        {
            "termDef": "Large - {Модель памяти} в которой и код и данные занимают несколько сегментов"
        },
        {
            "termDef": "Huge - {Модель памяти} которая может содержать несколько {сегментов} кода и насколько сегментов данных"
        },
        {
            "termDef": "Flat - {Модель памяти} в которой код, данные и стек находятся в одном сегменте, но используется 32х битная адресация"
        },
        {
            "termDef": "pusha - {Инструкция работы со стеком}, которая кладет в {стек} {регистры} в следующем порядке: {ax}, {cx}, {dx}, {bx}, {sp}, {bp}, {si} и {di}. Автоматически меняет {sp}"
        },
        {
            "termDef": "popa - {Инструкция работы со стеком}, которая кладет в {стек} {регистры} в следующем порядке: {di}, {si}, {bp}, {sp}, {bx}, {dx}, {cx} и {ax} Автоматически меняет {sp}"
        },
        {
            "termDef": "Инструкция работы со стеком - {Инструкция} совершающая манипуляции с сегментом {стека} (указанном в {ss}) модифицируя {sp}"
        },
        {
            "termDef": "Битовый сдвиг - {Операция}, которая сдвигает {биты} в числе на определенное количество шагов"
        },
        {
            "termDef": "shl - {Инструкция} {битового сдвига} влево"
        },
        {
            "termDef": "shr - {Инструкция} {битового сдвига} вправо"
        },
        {
            "termDef": "mul - {Арифметическая инструкция} умножения, которая умножает переданный {регистр} на al и оставляет результат в al"
        },
        {
            "termDef": "jmp dword ptr - команда дальнего перехода"
        },
        {
            "termDef": "retf - достает из {стека} {сегмент} и {смещение}. {процедура} может находиться в любом {сегменте}, независимо от того, откуда ее вызывают"
        },
        {
            "termDef": "and - {Логическая инструкция}"
        },
        {
            "termDef": "or - {Логическая инструкция}"
        },
        {
            "termDef": "Логическая инструкция - {Инструкция}, выполняющая булевы логические операции"
        },
        {
            "termDef": "ret n - аналогично команде {ret}, но в дополнение достает из стека n байт"
        },
        {
            "termDef": "equ - "
        },
        {
            "termDef": "scas - {Инструкция} выполняет поиск в массиве первого байта. При этом {es}:{di} содержит адрес строки, {cx} длина строки, а {al} искомый символ. В результате {di} будет указывать на символ"
        },
        {
            "termDef": "repne - repeat if not equal"
        },
        {
            "termDef": "repe - repeat if equal"
        },
        {
            "termDef": "psp - prefix segment program"
        },
        {
            "termDef": "test - инструкция, проверяющая значение отдельных {бит} в переменой. Если бит равен 1 то {флаг нуля} будет сброшен"
        },
        {
            "termDef": "Флаг четности - {флаг} в {регистре флагов} который содержит 1 если в результате последней операции в значении было четное число {значащих разрядов}, иначе 0"
        },
        {
            "termDef": "Флаг внешнего переноса - {Флаг} в {регистре флагов}, Контролирует перенос из 3-го бита данных. Полезен при операциях над упакованными десятичными цифрами"
        },
        {
            "termDef": "Флаг знака - {Флаг} в {регистре флагов}. Равен 1 если в результате операции получено отрицательное число"
        },
        {
            "termDef": "Флаг трассировки - {флаг} в {регистре флагов}. Равен 1, если программа выполняется по шагам, с передачей управления после каждой выполненной команды {прерыванию} с вектором 1"
        },
        {
            "termDef": "Флаг прерываний - {флаг} в {регистре флагов}. Содержит 1 если разрешена обработка {прерываний}"
        },
        {
            "termDef": "Флаг направления - {флаг} в {регистре флагов}. Управляет направлением передачи данных: если он содержит 0, то после каждой {индексной операции} содержимое {индексных регистров} увеличивается на 1, в противном случае — уменьшается на 1"
        },
        {
            "termDef": "Флаг переполнения - {флаг} в {регистре флагов}. Равен 1, если в результате операции получено число, выходящее за {разрядную сетку} процессора, т. е. число, превышающее максимальный размер {регистра} или {переменной}"
        },
        {
            "termDef": "PSP - "
        },
        {
            "termDef": "DTA - "
        },
        {
            "termDef": "jb - jump if below"
        },
        {
            "termDef": "jbe - jump if below or equal. {Инструкция условного перехода}. Переход выполняется если установлен {флаг переноса} или {флаг нуля}"
        },
        {
            "termDef": "jnb - jump if not below"
        },
        {
            "termDef": "ja - jump if above"
        },
        {
            "termDef": "jae - jump if above or equal"
        },
        {
            "termDef": "jna - jump if not above"
        },
        {
            "termDef": "stc - инструкция, устанавливающая {флаг переноса}. set carry flag"
        },
        {
            "termDef": "clc - инструкция, которая сбрасывает {флаг переноса}. Clear carry flag"
        },
        {
            "termDef": "std - инструкция устанавливающая {флаг направления}. Set destination flag"
        },
        {
            "termDef": "cld - инструкция, сбрасывающая {флаг направления}. Clear destination flag"
        },
        {
            "termDef": "FPU - floating point unit, часть {процессора}, выполняющая операции с плавающей точкой"
        },
        {
            "termDef": "st(0)-st(7) - 8 {регистров} {сопроцессора}"
        },
        {
            "termDef": "finit - {инструкция} инициализации {сопроцессора}"
        },
        {
            "termDef": "fild - {инструкция} {FPU} integer load"
        },
        {
            "termDef": "Инструкция - одна отдельная, {атомарная} операция {процессора}"
        },
        {
            "termDef": "fadd - {FPU} {инструкция} сложения {сопроцессора}"
        },
        {
            "termDef": "fist - {FPU} integer store. Сохранение целого числа из {сопроцессора} из регистра {st 0}"
        },
        {
            "termDef": "fistp - инструкция {fist} с дополнительным удалением значения из {st 0} fpu integer store and pop"
        },
        {
            "termDef": "EPB - exec parameter block"
        },
        {
            "termDef": "OBJ - "
        },
        {
            "termDef": "RAX - 64 {битный} {регистр}. Содержит а себе {EAX}"
        },
        {
            "termDef": "ECX - {CX}"
        },
        {
            "termDef": "EDX - {DX}"
        },
        {
            "termDef": "Процессор - интегральная схема, выполняющая логические и математические операции"
        },
        {
            "termDef": "ESP - расширенный {регистр} {SP}"
        },
        {
            "termDef": "EBP - расширенный {регистр} {BP}"
        },
        {
            "termDef": "ESI - расширенный {регистр} {SI}"
        },
        {
            "termDef": "EDI - расширенный {регистр} {DI}"
        },
        {
            "termDef": "EIP - расширенная версия регистра {IP}"
        },
        {
            "termDef": "EFLAGS - расширенный {регистр флагов}"
        },
        {
            "termDef": "Debug info format - "
        },
        {
            "termDef": "stabs - {Debug info format}"
        },
        {
            "termDef": "COFF - {Debug info format}"
        },
        {
            "termDef": "XCOFF - {Debug info format}"
        },
        {
            "termDef": "DWARF - {Debug info format}"
        }
    ]
}
